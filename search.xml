<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F02%2F15%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvascanvas画线条基本步骤 编写canvas标签 1&lt;canvas&gt;/&lt;canvas&gt; 获取canvas的dom元素 1var cas=document.querySelector("canvas"); 获取canvas的上下文对象(画笔) 1var ctx=cas.getContext("2d"); 设置起点 1ctx.moveTo(x,y); 设置终点 1ctx.lineTo(x,y); 描边(连线) 1ctx.stroke(); ​ 设置canvas的宽度和高度 在css中直接设置宽度和高度 其实是拉伸 在标签中通过属性的方式写宽度和高度(不叫做行内!!! ) 注意点 如果不写moveTo的话 那么lineTo 既是终点也是起点 首尾相连: 手动写lineTo ctx.closePath(); h5新标签 color标签 一般结合 onchange一起使用 1&lt;input type="color" /&gt; number标签 min 最小值 max 最大值 value 当前的值 step 步长 1&lt;input type="number" min=0 max=10 value=0 step=1 &gt; 操作数组的4个方法 原数组 arr=[a,b,c,d,e]; push 往屁股添加一个值 返回数组的长度 如: 6= arr.push(f) arr= [a, b, c, d,e,f]; pop 从屁股移除一个值 返回被删除的值 如: e= arr.pop() arr=[a,b,c,d]; unshift 从头部添加一个值 返回数组的长度如: 6= arr.unshift(f) arr=[f,a,b,c,d,e]; shift 从头部删除一个值 返回被删除的值 如: a= arr.shift() arr=[b,c,d,e]; eval 方法 可以把字符串变成代码执行 不要在工作里面出现 stroke和fill stroke 描边-对在同一条路径上的图形进行描边(封闭和不封闭) fill 填充 对同一条路径上的用线条画(不能填充strokeRect()的矩形)的封闭图形进行填充 路径 路径也是图形 判断两个图形是否在同一条路径上 不能够靠视觉上的首尾相连来判断 而是看有没有调用 ctx.beginPath(); 一般在画新图形之前,最好要 开启一条新的路径 线条属性 颜色 ctx.strokeStyle=”red”; ctx.fillStyle=”red”; 宽度 ctx.lineWidth=10; 线段末端类型 miter 默认 round 突出圆角 square 突出矩形 ctx.lineCap=”miter”; 线段相交点的类型 butt 屁股 默认值 round 圆角 bevel 平切 ctx.lineJoin=”butt”; 虚线 setLineDash([实线的长度,实线的间隙的长度……]) 设置虚线 getLineDash() 获取虚线 lineDashOffset=1 设置虚线的偏移值 内置画矩形和擦除 画矩形 stokeRect(x,y,width.height) 填充矩形 fillRect(x,y,width,height) 擦除 clearRect(x,y,width,height) 内置画圆弧 360 度=PI*2 return Math.PI/180* num ctx.arc(圆心x,圆心y,半径,开始的弧度,结束的弧度,?是否反向) 内置 画图片步骤:12345var img=new Image();img.src="路径";img.onload=function()&#123; ctx.drawImage()......&#125; 方法解释 3个参数 drawImage(图片对象,画在画布的x,画在画布的y); 5个参数 drawImage(图片对象,画在画布的x,画在画布的y,画多宽,画多高); 9个参数 drawImage(图片对象, 原图的x,原图的y,原图的宽,原图的高, 画在画布的x,画在画布的y,画多宽,画多高); 渐变决定渐变图案的因素 颜色 方向 长度 代码: 123456var g=ctx.creatLinearGradient(开始的坐标x,y,结束的坐标x,y);g.addColorStop(0,"red");g.addColorStop(1,"black");ctx.strokeStyle=g;ctx.fillStyle=g;ctx.fillRect(0,0,50,50); 文字ctx.strokeText(“文本”,x,y); ctx.fillText(“文本”,x,y); ctx.font=”50px 宋体” font的设置和在css中的设置一样 阴影ctx.shadowBlur 模糊值 ctx.shadowColor 颜色 ctx.shadowOffsetX x 偏移 ctx.shadowOffsetY y 偏移 1234ctx.shadowBlur=10;ctx.shadowColor="red";ctx.shadowOffsetX=10;ctx.shadowOffsetY=10; canvas中的转换移动css3中的移动和canvas中的移动的区别css3中的移动 移动的是自身的dom元素 移动的值 是覆盖的 先 translateX(100px) 再 tranlateX(200px) 最终的值 是 ranlateX(200px) 移动的单位 一个 百分比 % 一个是像素 px canvas中的移动 移动的是坐标系 移动的值是叠加的 先 translateX(100px) 再 tranlateX(200px) 最终的值 是 ranlateX(300px) 单位 不用写单位 1ctx.translate(1,1) 旋转css3中的旋转和canvas中的旋转的区别css3中的旋转 旋转的自身的dom元素 旋转的值 是覆盖的 单位 是 角度 旋转的中心点 是元素的中心 center center canvas中的旋转 旋转的是坐标系 旋转的值 是叠加的 单位 是 弧度!!!! 旋转的中心点是坐标系的圆点 0 0 1ctx.rotate(degToArc(10)); 环境环境 值 坐标系和线条属性 保存和还原保存的是 坐标系 和 线条属性 还原的是 坐标系 和 线条属性 保存了几次 就可以还原几次 12ctx.save()ctx.restore(); 擦除和重置擦除ctx.clearRect(0,0,100,100) 有时候 坐标系改变了的话 再使用擦除这个代码 坐标不一定是 0 0 不能擦除坐标系 不能擦除线条属性(颜色 大小 虚线 末端 相交🍌) 重置cas.width=cas.width 可以擦除画图的图案 可以重置坐标系 可以重置线条属性 下载标签实现1&lt;a href="资源路径" download="资源名字(可以随便写)" &gt;&lt;/a&gt; 代码实现12345678// 1 创建a标签var aDom=document.createElement(&quot;a&quot;);// 2 指定 hrefaDom.href=&quot;资源路径&quot;;// 3 设置download属性aDom.download=&quot;五年高考&quot;;// 4 手动触发 a标签的点击行为aDom.click();//它是个方法 不是 事件 画布保存和下载获取canvas画布的路径 cas.toDataURL()cas.ToDataURL(图片类型,质量)图片类型 image/png 默认值 即 cas.toDataURL() 既可以 不能压缩 image/jpeg 可以压缩 默认会把透明背景填充成黑色 建议在使用它的时候 先手动fill 画布 成白色 质量(0-1) 0 最低 1 最高画视频将video标签传入 ctx.drawImage(video,0,0) 即可 参数和 之前画图片的一样 在线视频截图下载报错: Uncaught DOMException: Failed to execute &#39;toDataURL&#39; on &#39;HTMLCanvasElement&#39;: Tainted canvases may not be exported. 解决:以服务器的形式打开即可 和canvas相关的技术 echartjs 百度 数据展示 文档详细 基于配置 konvajs 国外 自定义图形 类jq和js的关系 three.js 国外 3d模拟 门槛高 电脑性能要求高 d3.js 国外 大数据 门槛中 数据分析 移动web失真原因图片的清晰度和设备的清晰度不一致 解决方案: 不用解决 忍受 模糊 全部高清图 最常用 srcset 设备像素比的方式 devicePixelRatio 1&lt;img src="./images/科比.png" srcset="./images/赵丽颖.png 2x,./images/高圆圆.png 3x" alt=""&gt; ​ 基本概念 逻辑分辨率:屏幕的宽和高 单位 是px 设备分辨率:屏幕里面一共拥有的物理像素点的个数!!! 对角线:一般说的手机屏幕尺寸都是指对角线的长度 单位 是英寸 PPI (Pixels Per Inch)也叫像素密度，所表示的是每英寸所拥有的像素数量 值越高,越清晰 视口布局视口被手机厂商设置宽度为980px的视口 理想视口视口宽度和屏幕等宽并且使用绝对长度单位写元素大小 是固定 在代码里面如何写处理 meta:vp+tab 不标准的1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 标准的写法1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1,minimum-scale=1,user-scalable=no"&gt; less编译工具考拉注意事项 需要将 整个 css文件夹 都拖放到考拉当中 存放less文件的文件夹的名字不能够包含 less 字段 新创建less文件的时候 需要手动点击一下 考拉 里面的刷新按钮 reflash vs code 中的插件 easyless直接在vs code中下载 启用即可 语法:变量1234@myColor:red;body&#123; color:@myColor;&#125; 函数12345678910111213141516171819202122// 不带参数的函数.changeColor1()&#123; color:red;&#125;body&#123; .changeColor1();&#125;// 带参数的函数.changeColor2(@c)&#123; color:@c;&#125;body&#123; .changeColor2(red);&#125;// 带默认参数的函数.changeColor3(@c:black)&#123; color:@c;&#125;body&#123; .changeColor3();// color:black; .changeColor3(red);// color:red;&#125; ​ 嵌套12345div&#123; &amp;:after&#123;&#125; p&#123;&#125; &gt;section&#123;&#125;&#125; ​ 导入1@import "base.less"; ​ 注释12// 这种注释不会被编译到css中/* 这种注释会被编译到css中 */ 真机调试ghostlab 云真机 工作中如何对待: 1 公司里面有测试 开发者的只要确保在 模拟器上 没有bug 就可以了. 2 大公司里 有第三方的测试团队去测试 3 小小的公司 公司人少 只能够自己去测试 (再去研究真机调试的步骤) 5 在学习的时候 可以先不用管真机调试 .以后用到的时候再去搭建环境和步骤就可以 了 !!! 触屏事件触屏事件的种类touchstart 手指按下屏幕 touchemove 手指在屏幕上滑动 touchend 手指离开屏幕 三个触摸点数组touches 屏幕上所有的触摸点的集合 targetTouches 目标元素上的触摸点的集合 changedTouches 在目标元素上发生了状态改变(进入 离开 移动)的触摸点的集合 三对坐标信息clientX/Y 相对于视口的坐标 pageX/Y 相对于页面的坐标 screenX/Y 相对屏幕的坐标 触屏事件的注意点需求: 鼠标事件不能模拟多指触控 click点击事件在移动端存在延迟 原因 手机厂商为了用户更方便的放大页面 延迟机制: 第一次点击后,先等待一段时间 这一段时间过后 判断有没有第二次的点击发生 有 触发双击放大 没有的再触发单击 不管有没有第二次的点击 都需要等待 - 延迟 触屏事件不能在pc端上触发 建议绑定事件的时候 用 addEventListener 来绑定 手势封装tap判断依据: 手指个数不能超过1 按下时间不能超过300ms 滑动距离不能超过5px 手势封装swipe判断依据: 手指个数不能超过1 按下时间不能超过800ms 滑动距离不能小于15px 京东轮播图过渡结束事件transitionend 每一次过渡结束的时候 都会触发一次 移动端轮播图插件 swiper.js我们使用的版本是3.x版本 使用教程看官网即可 网站 vs code 插件1 安装 ease Server 插件 (同步刷新功能) 2 在当前的html页面中 输入 ctrl+shift+enter 自己构建zepto1 先安装好 nodejs 在cmd中输入 node -v 如果出现了版本号 证明安装成功了 2 在zepto文件夹内 按下 shift+鼠标右键 弹出命令行窗口 3 输入 npm install 4 执行编译 npm run-script dist 5 自己设置要编译的模块 SET MODULES=zepto event data touch 6 执行编译 npm run-script dist 响应式布局概念:用一套代码 可以做一个适应不同宽度的设备,还可以提供比较友好的用户体验 核心原理:媒体查询 媒体查询一种css的语法,可以根据设备的不同(主要是宽度),去加载对应的css代码 媒体查询的知识点媒体类型 all 包括一下两个类型 screen 带正常屏幕的设备 print 打印机 媒体特性 宽度 高度 视口的宽高比 123456// 2/1 不能改为 2@media screen and (aspect-ratio:2/1)&#123; body&#123; &#125;&#125; 媒体关键字 and or 代码中写逗号 来体现 not 取反 only 用来做兼容 媒体查询的引入方式 在css(和一般的样式代码是同层级)中直接写媒体查询-用得最多 在style标签上 通过属性的方式 在link标签上 通过属性的方式 bootstrap框架栅格系统是把所有屏幕(4种屏幕) 分成了12份 每一列占一份 4种宽度不同的屏幕 极小屏幕 xs &lt; 768px 小屏幕 sm 768-992 中等-普通屏幕 md 992-1200 大屏幕 lg &gt; 1200 步骤: 先写容器 .container(版心的宽度) .container-fluid (全屏) 写 .row 再去写栅格(要注意标明屏幕的种类) 工具提示用法: 直接粘贴标签的代码 必须要写上一段初始化的js代码 微金所知识点a标签不能嵌套a标签nth-child和nth-of-type的区别 nth-child 计算子元素索引的时候 会计算其他类型的标签 nth-of-type 计算子元素的索引的时候 不会计算其他类型的标签 列嵌套-有时候代码怎么简单怎么写在做大的布局的时候容器的时候 建议使用 块级元素 (千万不要写行内嵌套块级元素)rem+媒体查询 布局rem和px和em的区别 px是绝对长度单位 em是相对长度单位 相对于自身的fontsize 谷歌浏览器默认字体是16px 谷歌浏览器默认最小字体是12px rem 是相对长度单位 相对于html标签的fontsize 实现屏幕适配的步骤 使用rem+媒体查询还原设计稿 使用rem+媒体查询去做屏幕适配 适配的注意事项 基础值 和设计稿等宽的媒体查询里面的html标签的fontsize 为100px 写100px 是为了方便计算 公式: fontsize=基础值*要适配的屏幕/设计稿的宽度 不建议使用js来代替媒体查询的功能 任何宽度的设计稿都可以用这套解决方案 pc端的滚动条占宽度 移动端的滚动条不占宽度 在线工具标你妹 px转rem工具 开发技巧less和souce mapsouce map存放了less文件和css文件的映射关系 作用可以从页面调试工具里面 直接映射会对应的less文件 步骤: 使用工具创建souce map (考拉 vs code中插件 easyless) 考拉 easyless 插件 需要在vs code 的设置中 加入以下代码 就可以了 123&quot;less.compile&quot;: &#123; &quot;sourceMap&quot;: true // true =&gt; generate source maps (.css.map files) &#125;, 需要在谷歌浏览器中开启 ​ ​]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析node(二)]]></title>
    <url>%2F2018%2F02%2F13%2F%E6%B5%85%E6%9E%90nodejs-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[同步和异步的对比【非阻塞I/O和阻塞I/O】 异步读取文件 异步嵌套读取文件 同步读取文件 异步和同步操作中，捕获错误的方式 Node 中的模块化 什么是程序开发中的模块及好处 什么是程序开发中的模块化：把一些功能类似的代码，封装到一个单独的文件中去，这些单独抽离出来的代码文件，就能够提供各种各样好用的功能；这种通过代码功能分割文件的方式，叫做程序中的模块化； 好处：保证了每个文件的功能（职能）单一；需要什么特定的功能，直接调用某一个特定的模块；对将来程序开发和维护都有好处！ Node 中如何实现模块化 在Node中通过三个东西实现模块化： module：表示一个模块，在Node中，最常见的模块，就是一个个的JS文件！ require：作用是加载其他模块用的；在一个JS文件中，如何引用其他JS文件中的成员呢？就是用require exports：在Node的模块中，如果这个模块需要向外暴露一些成员，供其他JS模块使用，那么，需要使用exports向外暴露这些成员！ Node 中的模块化，主要解决的JS文件之间的相互依赖关系！ Node 中的模块的分类 node由三部分组成：ECMAScript + 核心API + 第三方等API 核心模块 什么是核心模块：官方，发现一些功能模块使用非常频繁，然后，官方把这些模块，编译成了二进制可执行文件，然后打包到了Node的安装包中；所以，这些核心模块就已经随着安装Node时候，被安装到了本地； 如何使用核心模块使用require（‘核心模块的名称’）； 第三方模块 什么是第三方模块：出了官方提供的好用的核心模块之外，我们程序员发现，还有一些使用也很频繁的代码和方法，一些牛逼的团体、个人、公司，开发出了好用的模块，通过NPM官网，托管出去，供其他人下载使用的这些模块；统称为第三方模块； 如何使用第三方模块－ 通过moment这个第三方模块，来介绍如何使用一个第三方模块； 第三方模块的使用方式： 先使用npm下载这个模块！【注意：在安装第三方模块的时候，安装的名字，就是你在require时候导入的名字】 使用require导入这个第三方模块！ 通过官方文档，试着去使用这个第三方模块！ 注意：无论是核心模块、还是第三方模块，都是通过 标识符名称来引用这个模块的！ 用户模块 什么是用户模块：程序员自己定义的JS文件，统统数据用户模块！ 用户模块向外导出成员的两种方式： 第一种方式：使用global对象，相当于浏览器中的window对象 全局变量污染， 不知道成员是从哪个模块中暴露 出去的 推荐Node提供的exports exports 和 module.exports 的区别 通过 module.exports 可以使用 . 的形式追加属性，也可以使用 等号 直接赋值的形式导出成员； exports 只能通过 . 的形式追加属性；不能使用 等号 直接赋值的形式！ 注意： 在一个 module 中，最终向外暴露的成员，以 module.exports 指向的对象为准！ 在一个模块中，不要混合使用 module.exports 和 exports 模块加载规则 优先从缓存中加载 加载核心模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载核心模块！ 自己的模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载用户模块！ 用户模块的查找规则： 用户模块的查找规则： 如果不写后缀名，则先严格按照给定的文件名去查找模块并加载执行； index -&gt; index.js -&gt; index.json -&gt; index.node 第三方模块查找规则： node首先，查看项目根目录中有没有 node_modules 文件夹 查找 node_modules 文件夹中，有没有和第三方模块名称一致的文件夹 在模块对应的文件夹中，查找有没有 package.json 这个文件 在 package.json 文件中，查找有没有 main 属性 如果有 main 属性，并且 main 属性指向的路径存在，那么就尝试加载这个路径指定的文件！ 如果 package.json 文件中，没有 main 属性，或者 main 属性指向的路径不存在，或者没有package.json 文件， 那么，Node尝试加载 模块根目录中 index 相关文件：index.js -&gt; index.json -&gt; index.node 如果在node_modules文件夹中，找不到对应的模块文件夹，或者在项目根目录中根本没有node_modules文件夹，则向上一层文件夹中去查找，查找规则同上！ 如果上一层目录中也没有查找到，则再向上翻一层去查找，直到找到当前项目所在的盘符根目录为止！ 如果找到了盘符根目录还找不到，则报错：cannot find module * 只安装部署依赖项不安装开发工具 npm i --production 模块化 node中的模块化基于commonJS:最显著的特点所有依赖项都是同步加载的！！！ commonJS由于是一个同步加载规范，所以不适合浏览器端使用；于是，浏览器端需要使用异步的模块加载机制 AMD、CMD 结合art-template模板引擎在服务器端渲染页面 art-template官方文档 服务端渲染和客户端渲染的对比 博客园官网 服务器端渲染 特点：Node服务器先读取模板页面，再获取要渲染的数据，然后直接在服务器端把完整的页面渲染拼接好，然后通过网络一次性的把结果发送给浏览器去显示！【注意：通过服务器端渲染，在网络中传输的是一个真正页面】 优点：请求次数少，速度快，对SEO友好 缺点：服务器渲染压力大【在后端可以通过缓存机制去解决】 客户端渲染 特点：先访问服务器获取到模板页面，然后再通过Ajax获取要渲染的数据，拿到这两者之后，再客户端调用模板引擎，渲染得到模板字符串，然后通过JS的方式，把结果展示到页面上！【真正的页面是在客户端浏览器中怼出来的，在进行网络传输的时候，第一次传输的是模板页面，第二次传输的是数据】 优点：减轻了服务器端的渲染压力 缺点：请求次数多，用户体验可能没有服务器端渲染好（白屏效果）；对SEO不友好 使用nodemon来自动重启Node服务 运行npm i nodemon -g全局安装模块 使用方式 和 node 完全一样： node 要执行文件的路径 nodemon 要执行文件的路径 文件列表小案例 获取文件的属性 在优化前, 先封装一个根据指定路径读取文件内容的方法【重点】 将读取文件夹的方法抽离出来，同时对error进行处理【重点】 相关文章 art-template 官方文档 ES6 - 模板字符串 js中的数组对象排序 i5ting/tocmd.npm 将MD转换为HTML]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析node]]></title>
    <url>%2F2018%2F02%2F13%2F%E6%B5%85%E6%9E%90nodejs%2F</url>
    <content type="text"><![CDATA[学习Node.js时候的建议 前端和后端的知识体系不同！不要使用前端的思维方式去学习后端开发！ 学习Node.js阶段，把自己当作后端开发人员！ 课堂上对重点的知识做笔记，利用一切时间练习课堂代码；晚上抽半个小时梳理总结今天所学知识点；整理今天的笔记！ 每天吃饭睡觉走大街上，都要在脑海中闪现今天学习的知识点【×××知识点是什么，怎么用】 什么是前端和后端 前端主要工作：写页面（HTML）、美化页面（CSS）、调用后台提供的API接口去请求或提交数据（JS）；Ajax （XHR、Jquery .ajax .get $.post），Jquery更多的是进行DOM方面的操作！H5C3，高级、Angular（单页面应用程序） 前端主要在浏览器端进行开发；前端主要和页面打交道，用户看到的基本上就是我们前端写出来的（前端就是颜值） 后端主要工作：主要进行业务逻辑的操作、比如数据的增删改查、操作数据库、对外暴露API接口（后台是骨骼、灵魂） 前后端协作流程：前端写页面，前端调用后台的接口；后台接受前端发过来的请求，然后进行相关的业务处理，把处理的结果返回给前端（提供API接口） Javascript 的起源 诞生：JS的诞生和一个公司有关，有一个网景公司；当时网速只有20~30KB（电话线），当时，就是为了进行客户端验证，为了减少不必要的网络请求，提高网络效率，网景公司决定研究一门语言，来解决这个问题；JS作者在10之内，就把这门语言写出来了，叫做LiveScript，为了搭上Java这般顺风车，就把LiveScript改名为Javascript； 浏览器中的一战：微软发现浏览器市场很火，然后就自己开发了一款浏览器【IE】；为了推广自己的IE浏览器，把IE捆绑到了Windows操作系统中；JScript 一战胜利的果实：ECMAScript标准的确立；就是一个语言规范；只规定了如何进行分支判断、如何定义变量、如何定义方法….. 短暂的和平期：IE6【微软发现自己已经天下无敌了，然后就把IE6的开发团队给解散了！】在和平期间，JS这门语言主要做什么：表单验证、简单的特效、狗皮膏药（当时被称为脚本语言） 二战：【主角：谷歌、IE、火（浴火重生）狐】谷歌在2008年，借助于AJax，开始火起来了！一方面提升渲染引擎的效率、另一方面，提升JS解析引擎的效率，最终，二战以谷歌的胜利结束；谷歌有了一款世界上效率最快的JS解析引擎，叫做chrome V8引擎； Node.js 的起源 nodejs的历史由来 作者，之前主要是做高性能服务器维护的；高性能的服务器有哪些必要的条件；必须要是异步非阻塞的、基于事件驱动的； 作者在分析了上面两条基本条件之后，就开始研发高性能服务器！ C,C++,Java,C#,Javascript 对于程序员来说，如果同时提供了同步和异步两种编程方式，程序员肯定会选择同步； 作者选择Javascript最主要的原因，就是这门语言是单线程的 多线程：程序员能主动开启子线程的语言，就叫做多线程的语言；Thread td = new Thread(); 作者最终，选择的语言是Javascript、解析引擎是V8； 刚开始，作者写出来的这个东西叫做web.js;后来，随着项目扩大和功能的完善，作者发现这款产品，不仅能做高性能的服务器，还能做许多事情，比如可以用这个东西去做前端包管理；于是就改名叫做Node.js; 像前端需要好用的工具，都是使用node.js开发出来的！ ECMAScript、浏览器中的Javascript、Node中的Javascript ECMAScript：语言规范；不能使用ECMAScript进行实际的编程，因为它只是一个语言标准而已； 浏览器中的Javascript：是ECMAScript这个规范的具体实现；我们可以使用浏览器中的JS进行实际的编程！ 浏览器中的Javascript组成部分：DOM + BOM + ECMAScript；其中，DOM和BOM和规范无关，是浏览器根据自己的需要，后期扩展的； Node中的Javascript：是ECMAScript这个规范的具体实现；也能进行实际的编程！ Node中的Javascript组成部分：ECMAScript + 核心API + 其他第三方API，由于Node不需要操作浏览器对象和文档对象，所以把BOM和DOM给剔除了！核心API中，提供了 操作 文件的API 和 操作网络的 API等。。。。 什么是Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 我们使用JS写的Node代码，说白了，只是单纯的字符串而已； 如果想要执行这些写好的代码，必须要有一个解析执行环境，这个环境就是chrome 的 V8 引擎； Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 事件驱动：当触发某个事件的时候，执行事件中指定的代码！ 非阻塞式 I/O 的模型：采用非阻塞的操作，能够提高处理的效率！ Node.js 的包管理器 npm，是全球最大的开源库生态系统。 先使用npm init -y初始化一下包管理文件package.json，将来所有安装的包，都会记录到这个文件中 使用npm install 包名 –save/–save-dev去安装包；其中，install可以简写成i; –save表示把包安装到部署依赖中（在开发和部署上线都需要使用的包）； –save-dev表示安装到开发依赖（只在项目开发阶段需要用到的包）； –save可以简写成-S；–save-dev可以简写成-D; npm uninstall 包名 –save/–save-dev或者npm remove 包名 –save/–save-dev npm i webpack -g,其中，-g表示全局安装某些包，通过-g安装的包都在C:\Users\用户名\AppData\Roaming\npm下面 NPM 和 （Github、码云） 和 Git之间的关系 NPM是包管理平台（里面托管了各种各样的包） Github、码云 代码托管平台（托管了各种各样的代码仓库） Git是用来对代码进行分支版本管理 补充：yarn yarn和npm的作用完全一样，都是用来管理项目中的第三方依赖包的！ yarn是Facebook公司推出来的一套包管理工具！【后期咱们学习React，尤其是ReactNative的时候，默认就是用Yarn去装包的】 yarn会缓存曾经安装过的包；但是npm也会缓存，但是效果不如yarn明显； yarn与npm的命令行小结 补充：如何设置npm和yarn的安装镜像： 什么是NPM淘宝镜像呢：由于每次安装包需要走国外的网络，速度很慢，所以，淘宝帮我们在国内创建了一个NPM包托管网站，能够提升使用NPM装包时候的速度！ 配置npm的国内淘宝镜像： npm config set registry https://registry.npm.taobao.org –global npm config set disturl https://npm.taobao.org/dist –global 配置yarn的国内淘宝镜像： yarn config set registry https://registry.npm.taobao.org –global yarn config set disturl https://npm.taobao.org/dist –global 总结：Node.js 就是一个Javascript的服务端运行环境（依赖于Chrome 的V8引擎），为Javascript提供了服务器端编程的能力！ Node.js 可以做哪些事情 【★】Node可以作为前端的一个工具去使用，通过NPM安装好用的工具；Node可以开发一些前端的工具【i5ting_toc】 【★】Node能做服务器 【★】Node还可以操作数据库并对外提供数据接口 Node能做即时聊天 【★★】为什么要学习Node.js 从企业角度分析： 企业对一专多能人才的需求：怎么才能最大限度的压榨员工；省钱 多高性能服务器的需求：怎么才能最大限度的压榨服务器； Node适合做快速的网络请求，但是不适合做大数据的业务逻辑的处理； 从自身角度分析： 挣钱； 对将来职业生涯有好处：学了Node之后，为我们构建了后端的知识体系，无论将来你会不会做后端的Node开发，但是，起码你已经构建了完整的前后端知识体系！ 后面学到的任何新技术：Vue.js，React,React-Native都是基于Node的！包括后面要学的一个构建工具webpack！ 在Node中执行相关的JS代码的两种方式 直接在命令行中输入node，进入Node的REPL运行环境： R：Read：读取用户输入的字符串内容 E：Evaluate：把用户输入的字符串，当作JS代码去解析执行 P：Print：打印输出Evaluate解析的结果 L：Loop：进入下一次循环 将Node代码写入到一个js文件中，然后通过node 要执行的JS文件路径去运行Node代码 环境变量 为什么可以通过命令行形式，直接启动node或者notepad呢？？？ 注意：每当修改了环境变量之后，需要重新启动命令窗口！ 什么是环境变量 Path环境变量的作用：能够让我们通过命令行的形式快速启动一个应用程序； 用户变量和系统变量的区别、 用户变量：用户变量是属于每一个用户的，用户之间的用户变量是私有的，不共享的； 系统变量：系统变量是共享的，只能用户能够登录这台电脑，那么就能访问系统变量中的任何东西！【将来咋在配置环境变量的时候，推荐大家配置到系统变量中！】 配置环境变量的两种方式 第一种方式：直接把路径添加到path环境变量中； 第二种方式：先在环境变量中创建一个新变量，名字类似于：ZOOM_HOME这样，值是我们程序的根目录；然后，再把这个变量名，引用到 Path环境变量中，类似于：%ZOOM_HOME% Path变量的查找规则 先从当前的目录中查找有没有这个应用程序，如果有，则直接运行，如果没有，则去系统环境变量中，path环境变量下挨个查找对应的文件夹，如果在对应文件夹中能找到，则直接运行，如果找不到，最终报错！ 【★★】使用fs模块来操作文件 fs.readFile fs.writeFile fs.appendFile 【★★★】fs模块中路径问题 箭头函数 Node中的使用http模块创建最基本的web服务器 之前有没有接触过Web服务器？？？ 其实，PHPStudy中集成了一个叫做Apache的软件；这个软件就是一个服务器软件，能够托管一个网站； 其实在Node中，并没有类似于Apache这样软件；我们可以通过简单的几行代码，写出一个Web服务器！ 【★★★】HTTP协议中的 请求 - 处理 - 响应 模型 【★★】step by step 构建HTTP服务器 升级1：根据不同的URL地址响应不同HTML消息 升级2：根据不同URL地址 - 响应不同的页面 升级3：在响应不同页面的同时响应静态资源（css、图片、js） 【★★★】【难点】升级4：根据不同URL地址 - 响应不同文件的改造 【★★】【难点】网页中资源请求路径问题 相关文章 JavaScript——历史与简介 深入浅出Node.js（一）：什么是Node.js I/O事件概述 理解Node.js事件驱动编程 Node.js 中文网 Node.js 英文官网 Node.js 菜鸟教程 CNode：Node.js专业中文社区 深入浅出Node.js(朴灵)完整扫描版.pdf HTTP Keep-Alive是什么？如何工作？ 浏览器User-agent String里的历史故事 art-template API yarn与npm的命令行小结]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度小目标]]></title>
    <url>%2F2018%2F01%2F01%2F2018%E5%B9%B4%E5%B9%B4%E5%BA%A6%E5%B0%8F%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[2018做什么？每一年都会给自己设置一个主题和主线，去尝试新的东西，当然大多数时候没有实现目标，一开始会因为总是没有实现而失望，渐渐也不再执着于结果，而是着重于在过程中更多的了解自己。 真的，认知自我是一个漫长的过程，作为一个内心敏感的人，尤其如此。 所以，在新的一年里，我想做以下的事情或尝试： -阅读：关于阅读，是一个我一直以来坚持的事情，持续的信息的输入，不至于囿于一个逻辑或者角度，新的一年打算阅读以下书籍： 《文明的冲突与世界秩序的重建》、《完全政变手册》、《暗店街》、《逻辑学导论 : （第11版）》、《大银行家》、《激荡三十年：中国企业1978~2008. 上》、《简单逻辑学》,如果你也喜欢阅读可以在豆瓣查看我的阅读历史的计划。 –摄影：单反买了小一年，也没有去系统的学习，好羞愧😫，本来想学好了以后拍妹子，然后找个漂亮的女票友，好像暴露了目的，ε=ε=ε=┏(゜ロ゜;)┛ -针织：别笑，我前几天突然很感兴趣，觉得好有意思，以前怎么没有留意这块？所以以后会留意这方面的信息。 -坚持长跑：特别怀念大学时候绕着内环跑步的日子。毕业后很久没有跑步，我没有别的特别喜欢的运动，跑步算是喜欢的一个。 -提升代码水平：每天坚持提交github，账号从2015年注册到现在，活跃度很低，向阮一峰学习。 -做几个我喜欢的demo，以前很多很好的想法没有去实现，现在慢慢有了将想法实现的能力，可以将之前的idea实现。 -努力攒钱，争取在后年或者大后年，攒够去阿根廷的旅游费用，当然最好是两人份的，很喜欢伊瓜苏瀑布、乌斯怀亚。我一直都认为，在伊瓜苏瀑布下的看瀑布的应该是一对。 暂时想到这里，就先写到这里吧！]]></content>
      <categories>
        <category>规划</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础语法]]></title>
    <url>%2F2017%2F12%2F20%2FPHP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目标 简单了解后端开发的流程，了解后端工作人员如何对数据进行处理，以便将来在工作中能更好的跟后端开发人员交流。 了解B/S架构开发的基本流程，能开发动态网站，并体会动态网站和静态网站的不同。 多了解一门编程语言，体会不同语言之间的异同。 前瞻知识点 B/S结构的处理流程 网络基本概念 IP 域名 DNS 网络DNS 本地DNS 端口 安装WAMP环境 W – web, A – Apache , M – MySql ,P – PHP hello world 所有PHP代码都放在标记： &lt;?php …… ?&gt; PHP输出方式：echo 1echo 'hello world' 注释 / 多行注释 / 多行注释不要嵌套 // 单行注释 语句分隔符 “;” PHP文件访问方式 PHP简介 PHP Hypertext Preprocessor 超文本预处理器，是嵌入到HTML文件中的服务器端的脚本语言； 一个PHP文件中，可以包含多种代码：HTML、CSS、JS、Jquery、PHP、MySQL等 PHP的语法，与C、Java、Python、JS语法比较相似； PHP是服务器端的脚本语言，脚本语言相对编程语言来说，要简单的多。 PHP程序只能运行在服务器端，在客户端看不见PHP任何代码； PHP文件的扩展名是以.php为后缀的。 语言基础 PHP与ASP、JSP一样，都是嵌入到HTML文件中的服务器端的脚本语言； PHP文件的后缀是.php PHP代码的标记：&lt;?php …… ?&gt; PHP中每行程序代码，必须以英文下的分号结束； 输出时间1echo date(&apos;Y-m-d H:i:s&apos;); 默认情况下PHP输出的时间是格林威治时间，比中国时区晚8个小时 解决方案： 1.0 找到PHP的配置文件 php.ini 2.0 定位到 date.timezone 3.0 设置中国时区 12; PRC为中华人民共和国date.timezone = PRC ​ 变量特点 变量是临时存储数据的容器； 变量是存储在内存当中； 网页执行完毕后，网页中相关的变量全部消失。 变量命名规则 变量名称只能包含：字母、数字、下划线 PHP中的变量名必须以 “\$” 符号开头，但是”\$”符号不属于变量的一部分，将来不管是赋值还是取值，都必须加上”\$” 变量名区分大小写 PHP中的变量使用不需要声明，直接赋值使用 常用的两种命名方法： 驼峰命名法 第一个单词的首字母小写，其余单词的首字母全部大写 如：userName，userId 帕斯卡命名法： 与驼峰命名法很像 唯一区别是它的首字母是大写 如：UserName,UserId 下划线命名法 所以的单词首字都小写，由下划线连接 如：user_name，user_id 变量的声明与赋值 声明 PHP中变量不需要声明，但是每个变量必须以$开 赋值： 直接给带有$的变量赋值 使用“=”，赋值运算符给变量赋值，“=”读作赋值运算符 赋值运算符的左边只能是一个变量名 如：$userName = “张三”; 变量值的读取 变量的数据类型由其中的内容决定 直接以 “$+变量名”的方式 取得可以取得变量的值 1$userName = "admin"; 可以使用“.”来连接将变量与字符串一起输出 1echo "我的名字叫".$userName 也可以在字符串的内部直接使用变量 在PHP中“.”点表示相连 在PHP中“+”加表示相加（是一种算术运算符） 123456 echo "我的名字叫做$userName"但是，如果用引号时，变量后面还有其它的有文字，就不能解析了如 echo "我的名字叫做$userName很高兴见到大家"这里就无法解析，需要在变量后面添加一个非空特殊字符，如： echo "我的名字叫做&#123;$userNmae&#125;很高兴见到大家"如果输出字符是单引号，则无法解析字符串 变量相关函数 header():设置服务器返回到浏览器的数据的类型 1header(&apos;content-type:text/html;charset=utf-8&apos;); isset() 判断变量是否存在 可以用来判断变量是否定义，或者是否为null empty() 判断变量是否为空 如果 var 是非空或非零的值，则 empty() 返回 FALSE “”、0、“0”、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的,也就意味着，如果上述的数据用empty来判断返回的结果都为true unset() 删除变量 可以通过这个函数删除一个已经存在的变量，删除之后变量为null 可以同步删除多个变量 如果在函数中 unset() 一个全局变量，则只是局部变量被销毁，而在调用环境中的变量将保持调用 unset() 之前一样的值。(这个当我们学了全局变量与局部变量以后再说) 1unset($a,$b,$c) var_dump() 显示变量的类型和值 可以同时打印多个变量 print_r() 显示数组的元素信息 如果是字符串，数字，boolean值，会原样输出 如果是数组，会详细打印数组信息 可变变量 指一个变量的名称，由另一个变量的值来充当 1234$a = "b";$b = "c";echo $b;//输出 cecho $$a;//输出 c 如果使用可变变量，一定要加上给可变变量的变量名加上{}作为定界符 变量的值传递和引用传递 JS中的基本数据类型(只有一个值)：字符串型、数值型、布尔型、undefined、null JS中的复合数据类型(多个值)：数组(Array)、对象(Object)、函数(Function) 值传递： 传递的是变量中保存的值 引用传递 传递的是变量保存的引用地址 在PHP中可以使用 &amp; 符号将值传递的变量改变为引用传递：如 1234$a = "abc";$b = &amp;$a;$a = "123";echo "$a&lt;br/&gt;$b" 常量概念 常量就是值永远不变的量，即：一旦赋值无法删除，修改。 由于变量在使用时还需要去它存储的地址中去找到对应的数据，相比变量来说，常量的速度要快。（存储地址？） 命名规则 与变量基本一致 变量名称只能包含：字母、数字、下划线，常量也是 PHP中的常量不需要使用$符号开头 常量名区分大小写，一般建议使用时尽量用大写，为了与变量区分开 常用的两种命名方法： 驼峰命名法 第一个单词的首字母小写，其余单词的首字母全部大写 如：uerName，userId 下划线命名法 所以的单词首字都小写，由下划线连接 如：user_name，user_id 常量定义define() 语法： bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) 案子：通过define关键来定义 123define('TITLE',"中华人民共和国");//定义常量TITLEdefine('TITLE',"中华人民共和国",true);//加上true，使用时既可以使用TITLE,又可以使用小写title，来使用常量define('TITLE',"中华人民共和国",false);//加上false，使用时必须使用TITLE 判断是否是常量：defined() 语法： bool defined ( string $name ) defined()可以判断常量 1defined(“TITLE”);//通过defined判断常量时，常量一定要加上引号 魔术常量 量的值在程序运行过程中不会改变。但是，魔术常量的值，会随着所在位置的不同而改变。 魔术常量都由系统定义好的，我们直接使用就好了，常用的有： __LINE__:得到当前代码的行号 __FILE__:得到当前文件的路径 __DIR__:得到当前文件所在目录 __FUNCTION__:得到所在函数 数据类型 数据类型分类 12345js中的数据类型： 简单数据类型： Number,string,bool,undefined 复杂数据类型 数组，对象，null 基本数据类型：字符串型(string)、整型(int)、浮点型(float：小数)、布尔型(bool) 复合数据类型：数组、对象 特殊数据类型：资源、NULL 数据类型判断 is_bool()，判断变量是不是布尔型 is_int()，判断变量是不是整型 is_string() 判断变量是不是字符串型 is_float() 判断变量是不是浮点型 is_numeric() 判断变量不是数值型或数字字符串。 is_array() 判断变量是不是数组 is_null() 判断变量是否为NULL is_resource() 判断变量是不是资源型 123456789//判断用户是否大于18岁，如果大于18岁，显示网页内容，如果没有，则不显示$age = 20;if(isset($age) &amp;&amp; is_numeric($age)) &#123; if($age &gt;18) &#123; echo('显示网页'); &#125; else &#123; echo ('不显示'); &#125;&#125; 整型 关键字：int 在js中所有的数字都用number来表示，但是在PHP，数字有不同的划分，其中整数（正整数，0，负整数）用整型来表示 整型包含正整数、负整数、零0 可以用10进制、八进制、16进制表示 123echo 100;//十进制echo 011;//八进制，以0开头的整数，结果为9echo 0x9a;//十六进制，以0x开头，结果为154 PHP中最大整数：PHP_INT_MAX，(2^31)-1 如果数字超出来了整数据范围，则类型会变为float 浮点型 关键字：float PHP中除了整数还有浮点型，一般浮点数会包含小数，比整型更加精确 浮点型的范围：1.8E-308~1.8E+308 注意点： 如果要对浮点数进行操作，就好先将浮点数转为整数再处理 1234567891011121314//以下做法不可取if(2.1/0.7 == 3) &#123; echo '相等';&#125; else &#123; echo '不相等';&#125;//以下是正确做法$a = 2.1 * 10;$b = 0.7 * 10;if($a/$b == 3) &#123; echo '相等';&#125; else &#123; echo '不相等';&#125; 字符串 字符串定义的四种方式 用单引号可以定义一个字符串；如：$a = ‘abc’; 单引号内无法解析变量 转义符号有：\’ 用双引号来定义一个字符串；如：$a = “abc”; 双引号内可以解析变量 转义符号有：\\、\’、\”、\$、\r、\n、\t 定义长字符串：heredoc 12345678910&lt;?phpheader('content-type:text/html;charset=utf-8');$a = 'abc';$aa = &lt;&lt;&lt;heredoc&lt;html&gt;123$a&lt;/html&gt;heredoc;echo $aa;?&gt; 使用注意： 1）字符串放在两个heredoc标签之间 2）以“&lt;&lt;&lt;heredoc”作为开始，不用带分号 3）以“heredoc;”作为结束，要带分号 4）标签名称可以自定义 5）结束标签必须放单独一行 定义长字符串：nowdoc 12345678910&lt;?phpheader('content-type:text/html;charset=utf-8');$a = 'abc';$aa = &lt;&lt;&lt;'nowdoc'&lt;html&gt;123$a&lt;/html&gt;nowdoc;echo $aa;?&gt; 使用注意： 与上述一样，但是开始的标签名必须加单引 不能解析变量 布尔型 关键字：bool 概念 true表示真，flase表示假 转换： 0,””,NULL,0.0,”0”,arry() 空数组会转为false 其它的数据都会转为true 空型 用null表示，表示没有 以下情况会出现NULL 可以直接给一个变量，赋一个NULL值； 未定义的变量的值，也是NULL； unset()删除一个变量后，该变量的值为NULL。 数据类型转换 概念 数据有不同的类型，有时间操作数据时需要转换类型以后才能完成操作，比如计算 类型的转换分为两种：自动转换（隐式转换）、手动转换（强制转换）在js中则被称为显示转换 大部分情况下数据是自动转换，少数情况下强制转换。 强制转换 通过关键字进行转换 12345678(bool)$a //强制转换为bool //除了0，0.0，”“，”0“，NULL，array()，转为false，其余都为true(int)$a //强制转换为int //转换会将小数去尾(string)$a //强制转换为string //null也可以转为‘’;(array)$a //强制转换为array(object)$a //强制转换为object 进制转换 进制就进位制，X进制，就是逢X进一。同理：十进制就是逢十进一，二进制逢二进一等等。 8进制：有8个基本数，分别为0、1、2、3、4、5、6、7，运算规则”逢8进1”； 16进制：有16个基本数，分别为0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，运算规则”逢16进1”。 2进制：有2个基本数，分别是0、1，运算规则”逢2进1”。 转换方法： decbin()将十进制转换为2进制 bindec()将2进制转换为十进制 decoct()将十进制转换为8进制 octdec()将八进制转换为10进制 dechex()将十进制转换为16进制 hexdec()将16进制转换为十进制 运算符 算数运算符+、-、*、/、%、++、– 赋值运算符=、+=、-=、*=、/=、%= 字符串运算符. 和 .= 案例：隔行变色 1234567891011121314151617181920212223&lt;?phpheader('content-type:text/html;charset=utf-8');$str = "&lt;table width='500' border='1' align='center'&gt;";$str .= "&lt;tr bgColor='#f0f0f'&gt;"; $str .= " &lt;th&gt;编号&lt;/th&gt;"; $str .= " &lt;th&gt;新闻编号&lt;/th&gt;"; $str .= " &lt;th&gt;发布时间&lt;/th&gt;"; $str .= "&lt;/tr&gt;";for($i = 0 ; $i &lt; 10 ; $i ++) &#123; if($i % 2 == 0) &#123; $str .= "&lt;tr bgColor='#f0f0f'&gt;"; &#125; else &#123; $str .= "&lt;tr&gt;"; &#125; $str .= "&lt;td&gt;$i&lt;/td&gt;"; $str .= "&lt;td&gt;&amp;nbsp;&lt;/td&gt;"; $str .= "&lt;td&gt;&amp;nbsp;&lt;/td&gt;"; $str .= "&lt;/tr&gt;";&#125;$str .= "&lt;/table&gt;";echo $str;?&gt; 比较运算符&gt;、&lt;、&gt;=、&lt;=、\=\=、!=、\=\=\=、!== 案例：字符串比较 ASCII码表：如果两个字符进行比较，比较的本质是它们对应的ASCII码 1echo (&quot;a&quot; &gt; 120); 逻辑运算符&amp;&amp;、||、! 实例：闰年判断 123456789//条件：//1）能够被4整除，且不能被100整除//2）能被400整除$year = 2000;if ($year%4 == 0 &amp;&amp; $year % 100 !=0 || $year % 400 ==0) &#123; echo "&#123;$year&#125;是闰年";&#125; else &#123; echo "&#123;$year&#125;不是闰年";&#125; 运算符优先级 三元运算符 案例：比较两个数的大小 123$a = 123;$b = 456;$max = $a &gt; $b ? $a : $b; 错误控制运算符（@） 作用：主要用来屏蔽表达式的错误： 可以用在变量、常量、函数调用之前，但是不能用在函数定义、类定义之前。 123$a = 100;$b = 0;echo @($a / $b); 流程控制 顺序结构 赋值语句 1$a = 123; 分支结构 分支结构（if） 多条件判断（if else if else） 案例：根据分数给评语。 多分支结构（switch） 案例：完成今天星期几 循环结构 while do while for break和continue 案例： 1）得到1~100的所有整数相加之和 2）输出100~1000以内所有水仙花数 3）输出九九乘法表 数组概念 数组是一组数的集合。如：$arr = array(1,2,3,4,5,6); PHP中数组的分类 枚举数组 数组元素的下标（索引），是从0开始的正整数，如：$arr = array(1,2,3,4,5,6); 关联数组： 数组元素的下标，是一个字符串。如：$arr[‘edu’] = ‘大专’ 关联数组无法通过数字下标取得对应的元素 混合数组： 两种下标都有的数组，就是混合数组。如：$arr = array(100, ‘edu’=&gt;’大专’ , ‘tel’ =&gt; ‘130110’) 多维数组： 数组元素的值，是一个数组，还可以理解为：数组嵌套数组。如：$arr[5][2] = 100 数组的创建 使用 array() 函数来创建数组 创建枚举数组： 下标是从0 开始的正整数 1$arr = array($value1,$value2,$value3,....); 创建关联数组 $key是重新给数组元素指定一个下标 下标和元素的值之间连接号是”=&gt;”，又称”重载元素下标” 1$arr = array([$key=&gt;]$value,[$key=&gt;]$value,[$key=&gt;]$value,....) 创建混合数组 有字符串下标的元素，就没有整型下标 如果$key省略了，就用默认下标 下标只能是整型以及字符串 如果元素没有指定下标，会在最大整数下标的基础上加1. 1$arr[] = $value 如果$arr数组不存在的话，会先创建数组，并添加第1个数组元素，第1个元素的下标为0 如果$arr已经存在 的话，添加新的数组元素，新的数组元素的下标，是最大整数下标+1 创建混合数组： 由语法1，2混合创建数组 123456$arr[] = 12;$arr[] = 13;$arr["a"] =14;$arr[] = 15;$arr[20] = 16;$arr[] = 19; 多维数组 多维数组，即数组中的元素又是一个数组 123456$arr = array( array(1,2,3,4), array(10,20,30,40), array('a','b','c'), "abc"); 数组中的函数 count() 计算数组中的单元数目或对象中的属性个数 语法：int count ( mixed $var [,\$mode = COUNT_NORMAL ] ) 参数： $var 是对象或者数组 $model: 如果可选的 mode 参数设为 COUNT_RECURSIVE（或 1），count() 将递归地对数组计数。对计算多维数组的所有单元尤其有用。mode 的默认值是 0。count()识别不了无限递归 unset() 删除变量或数组元素 语法：void unset ( mixed $var [, mixed $… ] ) 删除元素后，仅仅只是相当于将数据从数组中移除掉了，对数组的下标没有影响 数组的遍历 使用for加next()遍历数组 此方法比较麻烦 1234for($i = 0; $i &lt; count($arr); $i++) &#123; echo key($arr).current($arr)."&lt;br/&gt;" next($arr);&#125; key()：当前指针处元素的键名(下标)，不会移动指针 current()：返回当前指针处元素的值，不会移动指针 next(): 返回下一个元素的值，指针移动到下一个元素的开头 PHP中的数组传值时为值传递1234$arr = array(1,2,3,4);$arr1 = $arr;$arr1[0] = 100;echo $arr[0];//1 函数概念 函数是一段命名的代码段 封装一代码，将来要执行时可以直接调用 定义函数的方式1234567891011/* function 定义函数的关键字 functionName 函数的名称 arguments 形参列表 retValue 返回值 fnCode 功能代码*/function functionName(arguments)&#123; // fnCode return retValue;&#125; function： 定义函数的关键字，不区分大小写 functionName：函数名称，命名规则与变量一样，只是不需要加$符号 小括号()：主要用来接受传递过来的参数 arguments：定义函数时的参数，形参 return 函数的返回值。 函数的调用： 实参：调用函数时，传递的参数就是实参，含有真正数据的 形参：定义函数时的参数 案例：得到数组中所有数组的和 函数参数的传递： 值传递 函数参数的值传递，就是将参数的值，复制一份，传到函数中 值传递速度比较慢，但修改其中一个不会影响到另一个； 引用传递 引用传递速度比较快，但修改其中一个，另一个也会改变。 引用传递，是将一个变量的地址，复制一份，传到函数中 默认参数 函数中有些参数可能是固定不变的，为了操作方便，可以用默认参数来代替 默认参数必须放在非默认参数的右边 默认参数的值，只能是：字符串、整型、浮点型、布尔型、NULL、数组 123function showSelf($name,$age=19,$gender="男") &#123; echo "我叫&#123;$name&#125;，今天&#123;$age&#125;,性别&#123;$ender&#125;";&#125; 函数可变数量参数 func_get_args( void )：返回一个参数列表的枚举数组，参数数组的下标是从0开始的整数 func_get_arg( $index )：返回参数数组中，指定下标的参数的值； func_num_args( void )：返回实参的个数。 1234567891011121314function getSum() &#123; $arr = func_get_args(); $len = func_num_args(); $sum = 0; print_r($arr); echo "&lt;br/&gt;"; print_r($len); echo "&lt;br/&gt;"; for($i = 0; $i &lt; $len; $i++) &#123; $sum += func_get_arg($i); &#125; echo "$sum"; &#125; getSum(1,2,3,4,5); 函数的返回值 函数的返回值，通过return语句来实现； 将函数的执行结果，返给了函数调用者； return语句一旦执行，函数立即结束，函数剩余的代码不再执行了。 return语句有”中断”函数、”退出”函数； return不能同时返回多个值，只能返回一个值。如果想返回多个值，可以放入数组 常用系统函数字符串 定义字符串基本语法 单引号字符串 双引号字符串 nowdoc字符串 heredoc字符串 字符串常用api strlen() 获取字符串长度 substr() 返回字符串的子串 strtoupper() 将字符串转化为大写 strtolower() 将字符串转化为小写 ucfirst() 将字符串的首字母转换为大写 trim() 去除字符串首尾处的空白字符 ltrim() 删除字符串开头的空白字符 rtrim() 删除字符串末端的空白字符 strrev() 反转字符串 strpos() 查找字符串首次出现的位置，从左往右查找 strrpos() 计算指定字符串在目标字符串中最后一次出现的位置，从右往左查找 strchr()和strstr() 两者一样，用于查找字符串的首次出现 str_replace() 子字符串替换 str_repeat() 重复一个字符串 数学 常用函数 max() 求最大值 min() 求最小值 rand() 产生一个随机整数 mt_rand() 更高效的随机数 ceil() 进一法取整 floor() 舍去法取整 round() 对浮点数进行四舍五入 pow() 次方运算 abs() 求绝对值 sqrt() 开方运算 日期 常用函数 time() 返回自从 Unix 纪元（格林威治时间 1970 年 1 月 1 日 00:00:00）到当前时间的秒数 date() 格式化一个本地时间/日期 microtime() 返回当前 Unix 时间戳和微秒数 strtotime() 将任何英文文本的日期时间描述解析为 Unix 时间戳]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2017%2F12%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog!本博客基于Hexo博客框架搭建，并部署在GithubPages上，仍在不断完善中。 因为关于部署搭建的文章很多，所以我将不会赘述关于部署搭建相关的内容，不过在搭建的过程中的的确确遇到各种各样的小Bug，但是当网站搭建出来，老实说真的蛮开心的！ 页面的右下角是网站的“守护兽”，叫hijiki，毕竟我不经常有空更新，所以总要有人看家嘛！不要调戏它哦!超凶嘚！喵~ 如果你有什么想法或建议想与我联系，欢迎加我QQ1107840447或者你也可以邮箱发送到:mrgowell1994@gmail.com(墙外用户)或megowell@qq.com。 最后，欢迎您的访问，大爷！有空常来看看哟！]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
